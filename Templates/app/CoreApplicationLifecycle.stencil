import Foundation
import SwiftUI
import ComposableArchitecture
import Dependencies

public enum StartupResult: Equatable, Sendable {
    case ready
    case maintenance(message: String)
    case forceUpdate(minimumVersion: String)
    case error(message: String)
}

@Reducer
public struct ApplicationLifecycle: Sendable {
    @Dependency(\.lifecycleService) private var lifecycleService
    @Dependency(\.remoteConfigService) private var remoteConfigService
    @Dependency(\.analyticsService) private var analyticsService
    @Dependency(\.updateChecker) private var updateChecker

    @ObservableState
    public struct State: Equatable, Sendable {
        public var phase: ScenePhase = .inactive
        public var isValidating = false
        public var isValidationComplete = false
        public var isSplashAnimationComplete = false
        public var lastStartupError: String?

        @Shared(.appStorage(AppConstants.RemoteConfig.maintenanceModeEnabledKey)) public var isMaintenanceMode: Bool = AppConstants.RemoteConfig.defaultMaintenanceModeEnabled
        @Shared(.appStorage(AppConstants.RemoteConfig.maintenanceMessageKey)) public var maintenanceMessage: String = AppConstants.RemoteConfig.defaultMaintenanceMessage
        @Shared(.appStorage(AppConstants.RemoteConfig.forceUpdateMinimumVersionKey)) public var forceUpdateMinimumVersion: String = AppConstants.RemoteConfig.defaultForceUpdateMinimumVersion
        @Shared(.appStorage(AppConstants.RemoteConfig.welcomeMessageKey)) public var welcomeMessage: String = AppConstants.RemoteConfig.defaultWelcomeMessage
        @Shared(.appStorage(AppConstants.RemoteConfig.lastRemoteConfigSyncTimestampKey)) public var lastRemoteConfigSyncTimestamp: Double = 0
        @Shared(.appStorage(AppConstants.RemoteConfig.userLanguageCodeKey)) public var userLanguageCode: String = ""

        public init() {}

        public var effectiveLanguageCode: String {
            if !userLanguageCode.isEmpty { return userLanguageCode }
            return String((Locale.preferredLanguages.first ?? "en").prefix(2))
        }

        public var localizedWelcomeMessage: String {
            let parsed = LocalizedRemoteConfig.localize(welcomeMessage, forLanguage: effectiveLanguageCode) ?? "Welcome"
            return parsed.isEmpty ? "Welcome" : parsed
        }

        public var isCacheValid: Bool {
            guard lastRemoteConfigSyncTimestamp > 0 else { return false }
            return Date().timeIntervalSince1970 - lastRemoteConfigSyncTimestamp < AppConstants.Startup.cacheTTLSeconds
        }

        public var hasCachedConfig: Bool {
            lastRemoteConfigSyncTimestamp > 0
        }
    }

    @CasePathable
    public enum Action: Sendable, Equatable {
        case view(ViewAction)
        case `internal`(InternalAction)
        case delegate(DelegateAction)
    }

    public enum ViewAction: Sendable, Equatable {
        case initialize
        case retry
        case scenePhaseChanged(ScenePhase)
        case splashAnimationCompleted
    }

    public enum InternalAction: Sendable, Equatable {
        case validationFinished(StartupResult)
        case remoteConfigFetched(
            success: Bool,
            maintenanceMode: Bool,
            maintenanceMessage: String,
            forceUpdateMinimumVersion: String,
            welcomeMessage: String
        )
    }

    public enum DelegateAction: Sendable, Equatable {
        case startupResult(StartupResult)
        case showSplash
    }

    public init() {}

    public var body: some ReducerOf<Self> {
        Reduce { state, action in
            switch action {
            case .view(.initialize):
                state.lastStartupError = nil
                state.isValidating = true
                state.isValidationComplete = false
                state.isSplashAnimationComplete = false

                let cacheValid = state.isCacheValid
                let hasConfig = state.hasCachedConfig
                return .run { send in
                    await lifecycleService.initialize()
                    await validate(send: send, cacheValid: cacheValid, hasConfig: hasConfig)
                }

            case .view(.retry):
                state.lastStartupError = nil
                state.isValidating = true
                state.isValidationComplete = false
                state.isSplashAnimationComplete = false

                let cacheValid = state.isCacheValid
                let hasConfig = state.hasCachedConfig
                return .run { send in
                    await validate(send: send, cacheValid: cacheValid, hasConfig: hasConfig)
                }

            case .view(.splashAnimationCompleted):
                state.isSplashAnimationComplete = true
                if state.isValidationComplete {
                    return .send(.delegate(.startupResult(startupResult(from: state))))
                }
                return .none

            case let .view(.scenePhaseChanged(phase)):
                let previousPhase = state.phase
                guard previousPhase != phase else { return .none }
                state.phase = phase

                switch phase {
                case .active where previousPhase == .background:
                    if state.isCacheValid {
                        let result = startupResult(from: state)
                        return .run { send in
                            await lifecycleService.handleForeground()
                            if result != .ready {
                                await send(.delegate(.startupResult(result)))
                            }
                        }
                    }

                    let cacheValid = state.isCacheValid
                    let hasConfig = state.hasCachedConfig
                    state.isValidating = true
                    state.isValidationComplete = false
                    state.isSplashAnimationComplete = false
                    state.lastStartupError = nil

                    return .run { send in
                        await send(.delegate(.showSplash))
                        await validate(send: send, cacheValid: cacheValid, hasConfig: hasConfig)
                        await lifecycleService.handleForeground()
                    }

                case .background:
                    return .run { _ in
                        await lifecycleService.handleBackground()
                    }

                default:
                    return .none
                }

            case let .internal(.remoteConfigFetched(success, maintenanceMode, maintenanceMessage, forceUpdateMinimumVersion, welcomeMessage)):
                if success {
                    state.$isMaintenanceMode.withLock { $0 = maintenanceMode }
                    state.$maintenanceMessage.withLock { $0 = maintenanceMessage }
                    state.$forceUpdateMinimumVersion.withLock { $0 = forceUpdateMinimumVersion }
                    state.$welcomeMessage.withLock { $0 = welcomeMessage }
                    state.$lastRemoteConfigSyncTimestamp.withLock { $0 = Date().timeIntervalSince1970 }
                }

                let result = startupResult(from: state)
                if case .ready = result {
                    return .run { send in
                        await configureAnalyticsForReadyState()
                        await send(.internal(.validationFinished(.ready)))
                    }
                }
                return .send(.internal(.validationFinished(result)))

            case let .internal(.validationFinished(result)):
                state.isValidating = false
                state.isValidationComplete = true

                if case let .error(message) = result {
                    state.lastStartupError = message
                } else {
                    state.lastStartupError = nil
                }

                if state.isSplashAnimationComplete || result != .ready {
                    return .send(.delegate(.startupResult(result)))
                }
                return .none

            case .delegate:
                return .none
            }
        }
    }

    private enum StartupMessages {
        static let noNetworkError = "Please check your network connection and try again."
    }

    private func startupResult(from state: State) -> StartupResult {
        if state.isMaintenanceMode {
            let message = LocalizedRemoteConfig.localize(state.maintenanceMessage, forLanguage: state.effectiveLanguageCode) ?? "Maintenance in progress"
            return .maintenance(message: message)
        }

        let currentVersion = Bundle.main.object(forInfoDictionaryKey: "CFBundleShortVersionString") as? String ?? "0.0.0"
        if !state.forceUpdateMinimumVersion.isEmpty &&
            updateChecker.isUpdateRequired(currentVersion, state.forceUpdateMinimumVersion) {
            return .forceUpdate(minimumVersion: state.forceUpdateMinimumVersion)
        }

        return .ready
    }

    private func configureAnalyticsForReadyState() async {
        await analyticsService.updateEnabled(true)
        await analyticsService.logEvent(AppConstants.Analytics.SampleEvent(source: "startup"))
    }

    private func validate(
        send: Send<Action>,
        cacheValid: Bool,
        hasConfig: Bool
    ) async {
        do {
            try await remoteConfigService.fetchAndActivate()

            let forceUpdate = await remoteConfigService.string(AppConstants.RemoteConfig.forceUpdateMinimumVersionKey) ?? ""
            let maintenanceMode = await remoteConfigService.bool(AppConstants.RemoteConfig.maintenanceModeEnabledKey) ?? false
            let maintenanceMessage = await remoteConfigService.string(AppConstants.RemoteConfig.maintenanceMessageKey) ?? ""
            let welcomeMessage = await remoteConfigService.string(AppConstants.RemoteConfig.welcomeMessageKey) ?? ""

            await send(.internal(.remoteConfigFetched(
                success: true,
                maintenanceMode: maintenanceMode,
                maintenanceMessage: maintenanceMessage,
                forceUpdateMinimumVersion: forceUpdate,
                welcomeMessage: welcomeMessage
            )))
        } catch {
            let canFallback = cacheValid || hasConfig
            guard canFallback else {
                await send(.internal(.validationFinished(.error(message: StartupMessages.noNetworkError))))
                return
            }

            await send(.internal(.remoteConfigFetched(
                success: false,
                maintenanceMode: false,
                maintenanceMessage: "",
                forceUpdateMinimumVersion: "",
                welcomeMessage: ""
            )))
        }
    }
}
